// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'enumeration_twin_rust_async.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

DistanceTwinRustAsync _$DistanceTwinRustAsyncFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'unknown':
      return DistanceTwinRustAsync_Unknown.fromJson(json);
    case 'map':
      return DistanceTwinRustAsync_Map.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'DistanceTwinRustAsync',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$DistanceTwinRustAsync {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function(double field0) map,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function(double field0)? map,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function(double field0)? map,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DistanceTwinRustAsync_Unknown value) unknown,
    required TResult Function(DistanceTwinRustAsync_Map value) map,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DistanceTwinRustAsync_Unknown value)? unknown,
    TResult? Function(DistanceTwinRustAsync_Map value)? map,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DistanceTwinRustAsync_Unknown value)? unknown,
    TResult Function(DistanceTwinRustAsync_Map value)? map,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DistanceTwinRustAsyncCopyWith<$Res> {
  factory $DistanceTwinRustAsyncCopyWith(DistanceTwinRustAsync value,
          $Res Function(DistanceTwinRustAsync) then) =
      _$DistanceTwinRustAsyncCopyWithImpl<$Res, DistanceTwinRustAsync>;
}

/// @nodoc
class _$DistanceTwinRustAsyncCopyWithImpl<$Res,
        $Val extends DistanceTwinRustAsync>
    implements $DistanceTwinRustAsyncCopyWith<$Res> {
  _$DistanceTwinRustAsyncCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DistanceTwinRustAsync_UnknownImplCopyWith<$Res> {
  factory _$$DistanceTwinRustAsync_UnknownImplCopyWith(
          _$DistanceTwinRustAsync_UnknownImpl value,
          $Res Function(_$DistanceTwinRustAsync_UnknownImpl) then) =
      __$$DistanceTwinRustAsync_UnknownImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DistanceTwinRustAsync_UnknownImplCopyWithImpl<$Res>
    extends _$DistanceTwinRustAsyncCopyWithImpl<$Res,
        _$DistanceTwinRustAsync_UnknownImpl>
    implements _$$DistanceTwinRustAsync_UnknownImplCopyWith<$Res> {
  __$$DistanceTwinRustAsync_UnknownImplCopyWithImpl(
      _$DistanceTwinRustAsync_UnknownImpl _value,
      $Res Function(_$DistanceTwinRustAsync_UnknownImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$DistanceTwinRustAsync_UnknownImpl
    extends DistanceTwinRustAsync_Unknown {
  const _$DistanceTwinRustAsync_UnknownImpl({final String? $type})
      : $type = $type ?? 'unknown',
        super._();

  factory _$DistanceTwinRustAsync_UnknownImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$DistanceTwinRustAsync_UnknownImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'DistanceTwinRustAsync.unknown()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DistanceTwinRustAsync_UnknownImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function(double field0) map,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function(double field0)? map,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function(double field0)? map,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DistanceTwinRustAsync_Unknown value) unknown,
    required TResult Function(DistanceTwinRustAsync_Map value) map,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DistanceTwinRustAsync_Unknown value)? unknown,
    TResult? Function(DistanceTwinRustAsync_Map value)? map,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DistanceTwinRustAsync_Unknown value)? unknown,
    TResult Function(DistanceTwinRustAsync_Map value)? map,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$DistanceTwinRustAsync_UnknownImplToJson(
      this,
    );
  }
}

abstract class DistanceTwinRustAsync_Unknown extends DistanceTwinRustAsync {
  const factory DistanceTwinRustAsync_Unknown() =
      _$DistanceTwinRustAsync_UnknownImpl;
  const DistanceTwinRustAsync_Unknown._() : super._();

  factory DistanceTwinRustAsync_Unknown.fromJson(Map<String, dynamic> json) =
      _$DistanceTwinRustAsync_UnknownImpl.fromJson;
}

/// @nodoc
abstract class _$$DistanceTwinRustAsync_MapImplCopyWith<$Res> {
  factory _$$DistanceTwinRustAsync_MapImplCopyWith(
          _$DistanceTwinRustAsync_MapImpl value,
          $Res Function(_$DistanceTwinRustAsync_MapImpl) then) =
      __$$DistanceTwinRustAsync_MapImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$DistanceTwinRustAsync_MapImplCopyWithImpl<$Res>
    extends _$DistanceTwinRustAsyncCopyWithImpl<$Res,
        _$DistanceTwinRustAsync_MapImpl>
    implements _$$DistanceTwinRustAsync_MapImplCopyWith<$Res> {
  __$$DistanceTwinRustAsync_MapImplCopyWithImpl(
      _$DistanceTwinRustAsync_MapImpl _value,
      $Res Function(_$DistanceTwinRustAsync_MapImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$DistanceTwinRustAsync_MapImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DistanceTwinRustAsync_MapImpl extends DistanceTwinRustAsync_Map {
  const _$DistanceTwinRustAsync_MapImpl(this.field0, {final String? $type})
      : $type = $type ?? 'map',
        super._();

  factory _$DistanceTwinRustAsync_MapImpl.fromJson(Map<String, dynamic> json) =>
      _$$DistanceTwinRustAsync_MapImplFromJson(json);

  @override
  final double field0;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'DistanceTwinRustAsync.map(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DistanceTwinRustAsync_MapImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DistanceTwinRustAsync_MapImplCopyWith<_$DistanceTwinRustAsync_MapImpl>
      get copyWith => __$$DistanceTwinRustAsync_MapImplCopyWithImpl<
          _$DistanceTwinRustAsync_MapImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function(double field0) map,
  }) {
    return map(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function(double field0)? map,
  }) {
    return map?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function(double field0)? map,
    required TResult orElse(),
  }) {
    if (map != null) {
      return map(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DistanceTwinRustAsync_Unknown value) unknown,
    required TResult Function(DistanceTwinRustAsync_Map value) map,
  }) {
    return map(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DistanceTwinRustAsync_Unknown value)? unknown,
    TResult? Function(DistanceTwinRustAsync_Map value)? map,
  }) {
    return map?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DistanceTwinRustAsync_Unknown value)? unknown,
    TResult Function(DistanceTwinRustAsync_Map value)? map,
    required TResult orElse(),
  }) {
    if (map != null) {
      return map(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$DistanceTwinRustAsync_MapImplToJson(
      this,
    );
  }
}

abstract class DistanceTwinRustAsync_Map extends DistanceTwinRustAsync {
  const factory DistanceTwinRustAsync_Map(final double field0) =
      _$DistanceTwinRustAsync_MapImpl;
  const DistanceTwinRustAsync_Map._() : super._();

  factory DistanceTwinRustAsync_Map.fromJson(Map<String, dynamic> json) =
      _$DistanceTwinRustAsync_MapImpl.fromJson;

  double get field0;
  @JsonKey(ignore: true)
  _$$DistanceTwinRustAsync_MapImplCopyWith<_$DistanceTwinRustAsync_MapImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EnumWithItemMixedTwinRustAsync _$EnumWithItemMixedTwinRustAsyncFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'a':
      return EnumWithItemMixedTwinRustAsync_A.fromJson(json);
    case 'b':
      return EnumWithItemMixedTwinRustAsync_B.fromJson(json);
    case 'c':
      return EnumWithItemMixedTwinRustAsync_C.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'EnumWithItemMixedTwinRustAsync',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EnumWithItemMixedTwinRustAsync {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function(Uint8List field0) b,
    required TResult Function(String cField) c,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function(Uint8List field0)? b,
    TResult? Function(String cField)? c,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function(Uint8List field0)? b,
    TResult Function(String cField)? c,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemMixedTwinRustAsync_A value) a,
    required TResult Function(EnumWithItemMixedTwinRustAsync_B value) b,
    required TResult Function(EnumWithItemMixedTwinRustAsync_C value) c,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemMixedTwinRustAsync_A value)? a,
    TResult? Function(EnumWithItemMixedTwinRustAsync_B value)? b,
    TResult? Function(EnumWithItemMixedTwinRustAsync_C value)? c,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemMixedTwinRustAsync_A value)? a,
    TResult Function(EnumWithItemMixedTwinRustAsync_B value)? b,
    TResult Function(EnumWithItemMixedTwinRustAsync_C value)? c,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EnumWithItemMixedTwinRustAsyncCopyWith<$Res> {
  factory $EnumWithItemMixedTwinRustAsyncCopyWith(
          EnumWithItemMixedTwinRustAsync value,
          $Res Function(EnumWithItemMixedTwinRustAsync) then) =
      _$EnumWithItemMixedTwinRustAsyncCopyWithImpl<$Res,
          EnumWithItemMixedTwinRustAsync>;
}

/// @nodoc
class _$EnumWithItemMixedTwinRustAsyncCopyWithImpl<$Res,
        $Val extends EnumWithItemMixedTwinRustAsync>
    implements $EnumWithItemMixedTwinRustAsyncCopyWith<$Res> {
  _$EnumWithItemMixedTwinRustAsyncCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EnumWithItemMixedTwinRustAsync_AImplCopyWith<$Res> {
  factory _$$EnumWithItemMixedTwinRustAsync_AImplCopyWith(
          _$EnumWithItemMixedTwinRustAsync_AImpl value,
          $Res Function(_$EnumWithItemMixedTwinRustAsync_AImpl) then) =
      __$$EnumWithItemMixedTwinRustAsync_AImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EnumWithItemMixedTwinRustAsync_AImplCopyWithImpl<$Res>
    extends _$EnumWithItemMixedTwinRustAsyncCopyWithImpl<$Res,
        _$EnumWithItemMixedTwinRustAsync_AImpl>
    implements _$$EnumWithItemMixedTwinRustAsync_AImplCopyWith<$Res> {
  __$$EnumWithItemMixedTwinRustAsync_AImplCopyWithImpl(
      _$EnumWithItemMixedTwinRustAsync_AImpl _value,
      $Res Function(_$EnumWithItemMixedTwinRustAsync_AImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$EnumWithItemMixedTwinRustAsync_AImpl
    extends EnumWithItemMixedTwinRustAsync_A {
  const _$EnumWithItemMixedTwinRustAsync_AImpl({final String? $type})
      : $type = $type ?? 'a',
        super._();

  factory _$EnumWithItemMixedTwinRustAsync_AImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$EnumWithItemMixedTwinRustAsync_AImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EnumWithItemMixedTwinRustAsync.a()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnumWithItemMixedTwinRustAsync_AImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function(Uint8List field0) b,
    required TResult Function(String cField) c,
  }) {
    return a();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function(Uint8List field0)? b,
    TResult? Function(String cField)? c,
  }) {
    return a?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function(Uint8List field0)? b,
    TResult Function(String cField)? c,
    required TResult orElse(),
  }) {
    if (a != null) {
      return a();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemMixedTwinRustAsync_A value) a,
    required TResult Function(EnumWithItemMixedTwinRustAsync_B value) b,
    required TResult Function(EnumWithItemMixedTwinRustAsync_C value) c,
  }) {
    return a(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemMixedTwinRustAsync_A value)? a,
    TResult? Function(EnumWithItemMixedTwinRustAsync_B value)? b,
    TResult? Function(EnumWithItemMixedTwinRustAsync_C value)? c,
  }) {
    return a?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemMixedTwinRustAsync_A value)? a,
    TResult Function(EnumWithItemMixedTwinRustAsync_B value)? b,
    TResult Function(EnumWithItemMixedTwinRustAsync_C value)? c,
    required TResult orElse(),
  }) {
    if (a != null) {
      return a(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EnumWithItemMixedTwinRustAsync_AImplToJson(
      this,
    );
  }
}

abstract class EnumWithItemMixedTwinRustAsync_A
    extends EnumWithItemMixedTwinRustAsync {
  const factory EnumWithItemMixedTwinRustAsync_A() =
      _$EnumWithItemMixedTwinRustAsync_AImpl;
  const EnumWithItemMixedTwinRustAsync_A._() : super._();

  factory EnumWithItemMixedTwinRustAsync_A.fromJson(Map<String, dynamic> json) =
      _$EnumWithItemMixedTwinRustAsync_AImpl.fromJson;
}

/// @nodoc
abstract class _$$EnumWithItemMixedTwinRustAsync_BImplCopyWith<$Res> {
  factory _$$EnumWithItemMixedTwinRustAsync_BImplCopyWith(
          _$EnumWithItemMixedTwinRustAsync_BImpl value,
          $Res Function(_$EnumWithItemMixedTwinRustAsync_BImpl) then) =
      __$$EnumWithItemMixedTwinRustAsync_BImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class __$$EnumWithItemMixedTwinRustAsync_BImplCopyWithImpl<$Res>
    extends _$EnumWithItemMixedTwinRustAsyncCopyWithImpl<$Res,
        _$EnumWithItemMixedTwinRustAsync_BImpl>
    implements _$$EnumWithItemMixedTwinRustAsync_BImplCopyWith<$Res> {
  __$$EnumWithItemMixedTwinRustAsync_BImplCopyWithImpl(
      _$EnumWithItemMixedTwinRustAsync_BImpl _value,
      $Res Function(_$EnumWithItemMixedTwinRustAsync_BImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$EnumWithItemMixedTwinRustAsync_BImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EnumWithItemMixedTwinRustAsync_BImpl
    extends EnumWithItemMixedTwinRustAsync_B {
  const _$EnumWithItemMixedTwinRustAsync_BImpl(this.field0,
      {final String? $type})
      : $type = $type ?? 'b',
        super._();

  factory _$EnumWithItemMixedTwinRustAsync_BImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$EnumWithItemMixedTwinRustAsync_BImplFromJson(json);

  @override
  final Uint8List field0;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EnumWithItemMixedTwinRustAsync.b(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnumWithItemMixedTwinRustAsync_BImpl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EnumWithItemMixedTwinRustAsync_BImplCopyWith<
          _$EnumWithItemMixedTwinRustAsync_BImpl>
      get copyWith => __$$EnumWithItemMixedTwinRustAsync_BImplCopyWithImpl<
          _$EnumWithItemMixedTwinRustAsync_BImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function(Uint8List field0) b,
    required TResult Function(String cField) c,
  }) {
    return b(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function(Uint8List field0)? b,
    TResult? Function(String cField)? c,
  }) {
    return b?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function(Uint8List field0)? b,
    TResult Function(String cField)? c,
    required TResult orElse(),
  }) {
    if (b != null) {
      return b(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemMixedTwinRustAsync_A value) a,
    required TResult Function(EnumWithItemMixedTwinRustAsync_B value) b,
    required TResult Function(EnumWithItemMixedTwinRustAsync_C value) c,
  }) {
    return b(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemMixedTwinRustAsync_A value)? a,
    TResult? Function(EnumWithItemMixedTwinRustAsync_B value)? b,
    TResult? Function(EnumWithItemMixedTwinRustAsync_C value)? c,
  }) {
    return b?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemMixedTwinRustAsync_A value)? a,
    TResult Function(EnumWithItemMixedTwinRustAsync_B value)? b,
    TResult Function(EnumWithItemMixedTwinRustAsync_C value)? c,
    required TResult orElse(),
  }) {
    if (b != null) {
      return b(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EnumWithItemMixedTwinRustAsync_BImplToJson(
      this,
    );
  }
}

abstract class EnumWithItemMixedTwinRustAsync_B
    extends EnumWithItemMixedTwinRustAsync {
  const factory EnumWithItemMixedTwinRustAsync_B(final Uint8List field0) =
      _$EnumWithItemMixedTwinRustAsync_BImpl;
  const EnumWithItemMixedTwinRustAsync_B._() : super._();

  factory EnumWithItemMixedTwinRustAsync_B.fromJson(Map<String, dynamic> json) =
      _$EnumWithItemMixedTwinRustAsync_BImpl.fromJson;

  Uint8List get field0;
  @JsonKey(ignore: true)
  _$$EnumWithItemMixedTwinRustAsync_BImplCopyWith<
          _$EnumWithItemMixedTwinRustAsync_BImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EnumWithItemMixedTwinRustAsync_CImplCopyWith<$Res> {
  factory _$$EnumWithItemMixedTwinRustAsync_CImplCopyWith(
          _$EnumWithItemMixedTwinRustAsync_CImpl value,
          $Res Function(_$EnumWithItemMixedTwinRustAsync_CImpl) then) =
      __$$EnumWithItemMixedTwinRustAsync_CImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String cField});
}

/// @nodoc
class __$$EnumWithItemMixedTwinRustAsync_CImplCopyWithImpl<$Res>
    extends _$EnumWithItemMixedTwinRustAsyncCopyWithImpl<$Res,
        _$EnumWithItemMixedTwinRustAsync_CImpl>
    implements _$$EnumWithItemMixedTwinRustAsync_CImplCopyWith<$Res> {
  __$$EnumWithItemMixedTwinRustAsync_CImplCopyWithImpl(
      _$EnumWithItemMixedTwinRustAsync_CImpl _value,
      $Res Function(_$EnumWithItemMixedTwinRustAsync_CImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cField = null,
  }) {
    return _then(_$EnumWithItemMixedTwinRustAsync_CImpl(
      cField: null == cField
          ? _value.cField
          : cField // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EnumWithItemMixedTwinRustAsync_CImpl
    extends EnumWithItemMixedTwinRustAsync_C {
  const _$EnumWithItemMixedTwinRustAsync_CImpl(
      {required this.cField, final String? $type})
      : $type = $type ?? 'c',
        super._();

  factory _$EnumWithItemMixedTwinRustAsync_CImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$EnumWithItemMixedTwinRustAsync_CImplFromJson(json);

  @override
  final String cField;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EnumWithItemMixedTwinRustAsync.c(cField: $cField)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnumWithItemMixedTwinRustAsync_CImpl &&
            (identical(other.cField, cField) || other.cField == cField));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, cField);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EnumWithItemMixedTwinRustAsync_CImplCopyWith<
          _$EnumWithItemMixedTwinRustAsync_CImpl>
      get copyWith => __$$EnumWithItemMixedTwinRustAsync_CImplCopyWithImpl<
          _$EnumWithItemMixedTwinRustAsync_CImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function(Uint8List field0) b,
    required TResult Function(String cField) c,
  }) {
    return c(cField);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function(Uint8List field0)? b,
    TResult? Function(String cField)? c,
  }) {
    return c?.call(cField);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function(Uint8List field0)? b,
    TResult Function(String cField)? c,
    required TResult orElse(),
  }) {
    if (c != null) {
      return c(cField);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemMixedTwinRustAsync_A value) a,
    required TResult Function(EnumWithItemMixedTwinRustAsync_B value) b,
    required TResult Function(EnumWithItemMixedTwinRustAsync_C value) c,
  }) {
    return c(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemMixedTwinRustAsync_A value)? a,
    TResult? Function(EnumWithItemMixedTwinRustAsync_B value)? b,
    TResult? Function(EnumWithItemMixedTwinRustAsync_C value)? c,
  }) {
    return c?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemMixedTwinRustAsync_A value)? a,
    TResult Function(EnumWithItemMixedTwinRustAsync_B value)? b,
    TResult Function(EnumWithItemMixedTwinRustAsync_C value)? c,
    required TResult orElse(),
  }) {
    if (c != null) {
      return c(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EnumWithItemMixedTwinRustAsync_CImplToJson(
      this,
    );
  }
}

abstract class EnumWithItemMixedTwinRustAsync_C
    extends EnumWithItemMixedTwinRustAsync {
  const factory EnumWithItemMixedTwinRustAsync_C(
      {required final String cField}) = _$EnumWithItemMixedTwinRustAsync_CImpl;
  const EnumWithItemMixedTwinRustAsync_C._() : super._();

  factory EnumWithItemMixedTwinRustAsync_C.fromJson(Map<String, dynamic> json) =
      _$EnumWithItemMixedTwinRustAsync_CImpl.fromJson;

  String get cField;
  @JsonKey(ignore: true)
  _$$EnumWithItemMixedTwinRustAsync_CImplCopyWith<
          _$EnumWithItemMixedTwinRustAsync_CImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EnumWithItemStructTwinRustAsync _$EnumWithItemStructTwinRustAsyncFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'a':
      return EnumWithItemStructTwinRustAsync_A.fromJson(json);
    case 'b':
      return EnumWithItemStructTwinRustAsync_B.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'EnumWithItemStructTwinRustAsync',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EnumWithItemStructTwinRustAsync {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List aField) a,
    required TResult Function(Int32List bField) b,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List aField)? a,
    TResult? Function(Int32List bField)? b,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List aField)? a,
    TResult Function(Int32List bField)? b,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemStructTwinRustAsync_A value) a,
    required TResult Function(EnumWithItemStructTwinRustAsync_B value) b,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemStructTwinRustAsync_A value)? a,
    TResult? Function(EnumWithItemStructTwinRustAsync_B value)? b,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemStructTwinRustAsync_A value)? a,
    TResult Function(EnumWithItemStructTwinRustAsync_B value)? b,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EnumWithItemStructTwinRustAsyncCopyWith<$Res> {
  factory $EnumWithItemStructTwinRustAsyncCopyWith(
          EnumWithItemStructTwinRustAsync value,
          $Res Function(EnumWithItemStructTwinRustAsync) then) =
      _$EnumWithItemStructTwinRustAsyncCopyWithImpl<$Res,
          EnumWithItemStructTwinRustAsync>;
}

/// @nodoc
class _$EnumWithItemStructTwinRustAsyncCopyWithImpl<$Res,
        $Val extends EnumWithItemStructTwinRustAsync>
    implements $EnumWithItemStructTwinRustAsyncCopyWith<$Res> {
  _$EnumWithItemStructTwinRustAsyncCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EnumWithItemStructTwinRustAsync_AImplCopyWith<$Res> {
  factory _$$EnumWithItemStructTwinRustAsync_AImplCopyWith(
          _$EnumWithItemStructTwinRustAsync_AImpl value,
          $Res Function(_$EnumWithItemStructTwinRustAsync_AImpl) then) =
      __$$EnumWithItemStructTwinRustAsync_AImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List aField});
}

/// @nodoc
class __$$EnumWithItemStructTwinRustAsync_AImplCopyWithImpl<$Res>
    extends _$EnumWithItemStructTwinRustAsyncCopyWithImpl<$Res,
        _$EnumWithItemStructTwinRustAsync_AImpl>
    implements _$$EnumWithItemStructTwinRustAsync_AImplCopyWith<$Res> {
  __$$EnumWithItemStructTwinRustAsync_AImplCopyWithImpl(
      _$EnumWithItemStructTwinRustAsync_AImpl _value,
      $Res Function(_$EnumWithItemStructTwinRustAsync_AImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? aField = null,
  }) {
    return _then(_$EnumWithItemStructTwinRustAsync_AImpl(
      aField: null == aField
          ? _value.aField
          : aField // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EnumWithItemStructTwinRustAsync_AImpl
    extends EnumWithItemStructTwinRustAsync_A {
  const _$EnumWithItemStructTwinRustAsync_AImpl(
      {required this.aField, final String? $type})
      : $type = $type ?? 'a',
        super._();

  factory _$EnumWithItemStructTwinRustAsync_AImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$EnumWithItemStructTwinRustAsync_AImplFromJson(json);

  @override
  final Uint8List aField;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EnumWithItemStructTwinRustAsync.a(aField: $aField)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnumWithItemStructTwinRustAsync_AImpl &&
            const DeepCollectionEquality().equals(other.aField, aField));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(aField));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EnumWithItemStructTwinRustAsync_AImplCopyWith<
          _$EnumWithItemStructTwinRustAsync_AImpl>
      get copyWith => __$$EnumWithItemStructTwinRustAsync_AImplCopyWithImpl<
          _$EnumWithItemStructTwinRustAsync_AImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List aField) a,
    required TResult Function(Int32List bField) b,
  }) {
    return a(aField);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List aField)? a,
    TResult? Function(Int32List bField)? b,
  }) {
    return a?.call(aField);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List aField)? a,
    TResult Function(Int32List bField)? b,
    required TResult orElse(),
  }) {
    if (a != null) {
      return a(aField);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemStructTwinRustAsync_A value) a,
    required TResult Function(EnumWithItemStructTwinRustAsync_B value) b,
  }) {
    return a(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemStructTwinRustAsync_A value)? a,
    TResult? Function(EnumWithItemStructTwinRustAsync_B value)? b,
  }) {
    return a?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemStructTwinRustAsync_A value)? a,
    TResult Function(EnumWithItemStructTwinRustAsync_B value)? b,
    required TResult orElse(),
  }) {
    if (a != null) {
      return a(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EnumWithItemStructTwinRustAsync_AImplToJson(
      this,
    );
  }
}

abstract class EnumWithItemStructTwinRustAsync_A
    extends EnumWithItemStructTwinRustAsync {
  const factory EnumWithItemStructTwinRustAsync_A(
          {required final Uint8List aField}) =
      _$EnumWithItemStructTwinRustAsync_AImpl;
  const EnumWithItemStructTwinRustAsync_A._() : super._();

  factory EnumWithItemStructTwinRustAsync_A.fromJson(
          Map<String, dynamic> json) =
      _$EnumWithItemStructTwinRustAsync_AImpl.fromJson;

  Uint8List get aField;
  @JsonKey(ignore: true)
  _$$EnumWithItemStructTwinRustAsync_AImplCopyWith<
          _$EnumWithItemStructTwinRustAsync_AImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EnumWithItemStructTwinRustAsync_BImplCopyWith<$Res> {
  factory _$$EnumWithItemStructTwinRustAsync_BImplCopyWith(
          _$EnumWithItemStructTwinRustAsync_BImpl value,
          $Res Function(_$EnumWithItemStructTwinRustAsync_BImpl) then) =
      __$$EnumWithItemStructTwinRustAsync_BImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Int32List bField});
}

/// @nodoc
class __$$EnumWithItemStructTwinRustAsync_BImplCopyWithImpl<$Res>
    extends _$EnumWithItemStructTwinRustAsyncCopyWithImpl<$Res,
        _$EnumWithItemStructTwinRustAsync_BImpl>
    implements _$$EnumWithItemStructTwinRustAsync_BImplCopyWith<$Res> {
  __$$EnumWithItemStructTwinRustAsync_BImplCopyWithImpl(
      _$EnumWithItemStructTwinRustAsync_BImpl _value,
      $Res Function(_$EnumWithItemStructTwinRustAsync_BImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bField = null,
  }) {
    return _then(_$EnumWithItemStructTwinRustAsync_BImpl(
      bField: null == bField
          ? _value.bField
          : bField // ignore: cast_nullable_to_non_nullable
              as Int32List,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EnumWithItemStructTwinRustAsync_BImpl
    extends EnumWithItemStructTwinRustAsync_B {
  const _$EnumWithItemStructTwinRustAsync_BImpl(
      {required this.bField, final String? $type})
      : $type = $type ?? 'b',
        super._();

  factory _$EnumWithItemStructTwinRustAsync_BImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$EnumWithItemStructTwinRustAsync_BImplFromJson(json);

  @override
  final Int32List bField;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EnumWithItemStructTwinRustAsync.b(bField: $bField)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnumWithItemStructTwinRustAsync_BImpl &&
            const DeepCollectionEquality().equals(other.bField, bField));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(bField));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EnumWithItemStructTwinRustAsync_BImplCopyWith<
          _$EnumWithItemStructTwinRustAsync_BImpl>
      get copyWith => __$$EnumWithItemStructTwinRustAsync_BImplCopyWithImpl<
          _$EnumWithItemStructTwinRustAsync_BImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List aField) a,
    required TResult Function(Int32List bField) b,
  }) {
    return b(bField);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List aField)? a,
    TResult? Function(Int32List bField)? b,
  }) {
    return b?.call(bField);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List aField)? a,
    TResult Function(Int32List bField)? b,
    required TResult orElse(),
  }) {
    if (b != null) {
      return b(bField);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemStructTwinRustAsync_A value) a,
    required TResult Function(EnumWithItemStructTwinRustAsync_B value) b,
  }) {
    return b(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemStructTwinRustAsync_A value)? a,
    TResult? Function(EnumWithItemStructTwinRustAsync_B value)? b,
  }) {
    return b?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemStructTwinRustAsync_A value)? a,
    TResult Function(EnumWithItemStructTwinRustAsync_B value)? b,
    required TResult orElse(),
  }) {
    if (b != null) {
      return b(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EnumWithItemStructTwinRustAsync_BImplToJson(
      this,
    );
  }
}

abstract class EnumWithItemStructTwinRustAsync_B
    extends EnumWithItemStructTwinRustAsync {
  const factory EnumWithItemStructTwinRustAsync_B(
          {required final Int32List bField}) =
      _$EnumWithItemStructTwinRustAsync_BImpl;
  const EnumWithItemStructTwinRustAsync_B._() : super._();

  factory EnumWithItemStructTwinRustAsync_B.fromJson(
          Map<String, dynamic> json) =
      _$EnumWithItemStructTwinRustAsync_BImpl.fromJson;

  Int32List get bField;
  @JsonKey(ignore: true)
  _$$EnumWithItemStructTwinRustAsync_BImplCopyWith<
          _$EnumWithItemStructTwinRustAsync_BImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EnumWithItemTupleTwinRustAsync _$EnumWithItemTupleTwinRustAsyncFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'a':
      return EnumWithItemTupleTwinRustAsync_A.fromJson(json);
    case 'b':
      return EnumWithItemTupleTwinRustAsync_B.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'EnumWithItemTupleTwinRustAsync',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$EnumWithItemTupleTwinRustAsync {
  List<int> get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List field0) a,
    required TResult Function(Int32List field0) b,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List field0)? a,
    TResult? Function(Int32List field0)? b,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List field0)? a,
    TResult Function(Int32List field0)? b,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemTupleTwinRustAsync_A value) a,
    required TResult Function(EnumWithItemTupleTwinRustAsync_B value) b,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemTupleTwinRustAsync_A value)? a,
    TResult? Function(EnumWithItemTupleTwinRustAsync_B value)? b,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemTupleTwinRustAsync_A value)? a,
    TResult Function(EnumWithItemTupleTwinRustAsync_B value)? b,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EnumWithItemTupleTwinRustAsyncCopyWith<$Res> {
  factory $EnumWithItemTupleTwinRustAsyncCopyWith(
          EnumWithItemTupleTwinRustAsync value,
          $Res Function(EnumWithItemTupleTwinRustAsync) then) =
      _$EnumWithItemTupleTwinRustAsyncCopyWithImpl<$Res,
          EnumWithItemTupleTwinRustAsync>;
}

/// @nodoc
class _$EnumWithItemTupleTwinRustAsyncCopyWithImpl<$Res,
        $Val extends EnumWithItemTupleTwinRustAsync>
    implements $EnumWithItemTupleTwinRustAsyncCopyWith<$Res> {
  _$EnumWithItemTupleTwinRustAsyncCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EnumWithItemTupleTwinRustAsync_AImplCopyWith<$Res> {
  factory _$$EnumWithItemTupleTwinRustAsync_AImplCopyWith(
          _$EnumWithItemTupleTwinRustAsync_AImpl value,
          $Res Function(_$EnumWithItemTupleTwinRustAsync_AImpl) then) =
      __$$EnumWithItemTupleTwinRustAsync_AImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class __$$EnumWithItemTupleTwinRustAsync_AImplCopyWithImpl<$Res>
    extends _$EnumWithItemTupleTwinRustAsyncCopyWithImpl<$Res,
        _$EnumWithItemTupleTwinRustAsync_AImpl>
    implements _$$EnumWithItemTupleTwinRustAsync_AImplCopyWith<$Res> {
  __$$EnumWithItemTupleTwinRustAsync_AImplCopyWithImpl(
      _$EnumWithItemTupleTwinRustAsync_AImpl _value,
      $Res Function(_$EnumWithItemTupleTwinRustAsync_AImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$EnumWithItemTupleTwinRustAsync_AImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EnumWithItemTupleTwinRustAsync_AImpl
    extends EnumWithItemTupleTwinRustAsync_A {
  const _$EnumWithItemTupleTwinRustAsync_AImpl(this.field0,
      {final String? $type})
      : $type = $type ?? 'a',
        super._();

  factory _$EnumWithItemTupleTwinRustAsync_AImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$EnumWithItemTupleTwinRustAsync_AImplFromJson(json);

  @override
  final Uint8List field0;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EnumWithItemTupleTwinRustAsync.a(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnumWithItemTupleTwinRustAsync_AImpl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EnumWithItemTupleTwinRustAsync_AImplCopyWith<
          _$EnumWithItemTupleTwinRustAsync_AImpl>
      get copyWith => __$$EnumWithItemTupleTwinRustAsync_AImplCopyWithImpl<
          _$EnumWithItemTupleTwinRustAsync_AImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List field0) a,
    required TResult Function(Int32List field0) b,
  }) {
    return a(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List field0)? a,
    TResult? Function(Int32List field0)? b,
  }) {
    return a?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List field0)? a,
    TResult Function(Int32List field0)? b,
    required TResult orElse(),
  }) {
    if (a != null) {
      return a(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemTupleTwinRustAsync_A value) a,
    required TResult Function(EnumWithItemTupleTwinRustAsync_B value) b,
  }) {
    return a(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemTupleTwinRustAsync_A value)? a,
    TResult? Function(EnumWithItemTupleTwinRustAsync_B value)? b,
  }) {
    return a?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemTupleTwinRustAsync_A value)? a,
    TResult Function(EnumWithItemTupleTwinRustAsync_B value)? b,
    required TResult orElse(),
  }) {
    if (a != null) {
      return a(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EnumWithItemTupleTwinRustAsync_AImplToJson(
      this,
    );
  }
}

abstract class EnumWithItemTupleTwinRustAsync_A
    extends EnumWithItemTupleTwinRustAsync {
  const factory EnumWithItemTupleTwinRustAsync_A(final Uint8List field0) =
      _$EnumWithItemTupleTwinRustAsync_AImpl;
  const EnumWithItemTupleTwinRustAsync_A._() : super._();

  factory EnumWithItemTupleTwinRustAsync_A.fromJson(Map<String, dynamic> json) =
      _$EnumWithItemTupleTwinRustAsync_AImpl.fromJson;

  @override
  Uint8List get field0;
  @JsonKey(ignore: true)
  _$$EnumWithItemTupleTwinRustAsync_AImplCopyWith<
          _$EnumWithItemTupleTwinRustAsync_AImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EnumWithItemTupleTwinRustAsync_BImplCopyWith<$Res> {
  factory _$$EnumWithItemTupleTwinRustAsync_BImplCopyWith(
          _$EnumWithItemTupleTwinRustAsync_BImpl value,
          $Res Function(_$EnumWithItemTupleTwinRustAsync_BImpl) then) =
      __$$EnumWithItemTupleTwinRustAsync_BImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Int32List field0});
}

/// @nodoc
class __$$EnumWithItemTupleTwinRustAsync_BImplCopyWithImpl<$Res>
    extends _$EnumWithItemTupleTwinRustAsyncCopyWithImpl<$Res,
        _$EnumWithItemTupleTwinRustAsync_BImpl>
    implements _$$EnumWithItemTupleTwinRustAsync_BImplCopyWith<$Res> {
  __$$EnumWithItemTupleTwinRustAsync_BImplCopyWithImpl(
      _$EnumWithItemTupleTwinRustAsync_BImpl _value,
      $Res Function(_$EnumWithItemTupleTwinRustAsync_BImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$EnumWithItemTupleTwinRustAsync_BImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Int32List,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EnumWithItemTupleTwinRustAsync_BImpl
    extends EnumWithItemTupleTwinRustAsync_B {
  const _$EnumWithItemTupleTwinRustAsync_BImpl(this.field0,
      {final String? $type})
      : $type = $type ?? 'b',
        super._();

  factory _$EnumWithItemTupleTwinRustAsync_BImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$EnumWithItemTupleTwinRustAsync_BImplFromJson(json);

  @override
  final Int32List field0;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'EnumWithItemTupleTwinRustAsync.b(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnumWithItemTupleTwinRustAsync_BImpl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EnumWithItemTupleTwinRustAsync_BImplCopyWith<
          _$EnumWithItemTupleTwinRustAsync_BImpl>
      get copyWith => __$$EnumWithItemTupleTwinRustAsync_BImplCopyWithImpl<
          _$EnumWithItemTupleTwinRustAsync_BImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List field0) a,
    required TResult Function(Int32List field0) b,
  }) {
    return b(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List field0)? a,
    TResult? Function(Int32List field0)? b,
  }) {
    return b?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List field0)? a,
    TResult Function(Int32List field0)? b,
    required TResult orElse(),
  }) {
    if (b != null) {
      return b(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemTupleTwinRustAsync_A value) a,
    required TResult Function(EnumWithItemTupleTwinRustAsync_B value) b,
  }) {
    return b(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemTupleTwinRustAsync_A value)? a,
    TResult? Function(EnumWithItemTupleTwinRustAsync_B value)? b,
  }) {
    return b?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemTupleTwinRustAsync_A value)? a,
    TResult Function(EnumWithItemTupleTwinRustAsync_B value)? b,
    required TResult orElse(),
  }) {
    if (b != null) {
      return b(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EnumWithItemTupleTwinRustAsync_BImplToJson(
      this,
    );
  }
}

abstract class EnumWithItemTupleTwinRustAsync_B
    extends EnumWithItemTupleTwinRustAsync {
  const factory EnumWithItemTupleTwinRustAsync_B(final Int32List field0) =
      _$EnumWithItemTupleTwinRustAsync_BImpl;
  const EnumWithItemTupleTwinRustAsync_B._() : super._();

  factory EnumWithItemTupleTwinRustAsync_B.fromJson(Map<String, dynamic> json) =
      _$EnumWithItemTupleTwinRustAsync_BImpl.fromJson;

  @override
  Int32List get field0;
  @JsonKey(ignore: true)
  _$$EnumWithItemTupleTwinRustAsync_BImplCopyWith<
          _$EnumWithItemTupleTwinRustAsync_BImpl>
      get copyWith => throw _privateConstructorUsedError;
}

KitchenSinkTwinRustAsync _$KitchenSinkTwinRustAsyncFromJson(
    Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'empty':
      return KitchenSinkTwinRustAsync_Empty.fromJson(json);
    case 'primitives':
      return KitchenSinkTwinRustAsync_Primitives.fromJson(json);
    case 'nested':
      return KitchenSinkTwinRustAsync_Nested.fromJson(json);
    case 'optional':
      return KitchenSinkTwinRustAsync_Optional.fromJson(json);
    case 'buffer':
      return KitchenSinkTwinRustAsync_Buffer.fromJson(json);
    case 'enums':
      return KitchenSinkTwinRustAsync_Enums.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'KitchenSinkTwinRustAsync',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$KitchenSinkTwinRustAsync {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(int int32, double float64, bool boolean)
        primitives,
    required TResult Function(int field0, KitchenSinkTwinRustAsync field1)
        nested,
    required TResult Function(int? field0, int? field1) optional,
    required TResult Function(Uint8List field0) buffer,
    required TResult Function(WeekdaysTwinRustAsync field0) enums,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(int int32, double float64, bool boolean)? primitives,
    TResult? Function(int field0, KitchenSinkTwinRustAsync field1)? nested,
    TResult? Function(int? field0, int? field1)? optional,
    TResult? Function(Uint8List field0)? buffer,
    TResult? Function(WeekdaysTwinRustAsync field0)? enums,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(int int32, double float64, bool boolean)? primitives,
    TResult Function(int field0, KitchenSinkTwinRustAsync field1)? nested,
    TResult Function(int? field0, int? field1)? optional,
    TResult Function(Uint8List field0)? buffer,
    TResult Function(WeekdaysTwinRustAsync field0)? enums,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(KitchenSinkTwinRustAsync_Empty value) empty,
    required TResult Function(KitchenSinkTwinRustAsync_Primitives value)
        primitives,
    required TResult Function(KitchenSinkTwinRustAsync_Nested value) nested,
    required TResult Function(KitchenSinkTwinRustAsync_Optional value) optional,
    required TResult Function(KitchenSinkTwinRustAsync_Buffer value) buffer,
    required TResult Function(KitchenSinkTwinRustAsync_Enums value) enums,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(KitchenSinkTwinRustAsync_Empty value)? empty,
    TResult? Function(KitchenSinkTwinRustAsync_Primitives value)? primitives,
    TResult? Function(KitchenSinkTwinRustAsync_Nested value)? nested,
    TResult? Function(KitchenSinkTwinRustAsync_Optional value)? optional,
    TResult? Function(KitchenSinkTwinRustAsync_Buffer value)? buffer,
    TResult? Function(KitchenSinkTwinRustAsync_Enums value)? enums,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(KitchenSinkTwinRustAsync_Empty value)? empty,
    TResult Function(KitchenSinkTwinRustAsync_Primitives value)? primitives,
    TResult Function(KitchenSinkTwinRustAsync_Nested value)? nested,
    TResult Function(KitchenSinkTwinRustAsync_Optional value)? optional,
    TResult Function(KitchenSinkTwinRustAsync_Buffer value)? buffer,
    TResult Function(KitchenSinkTwinRustAsync_Enums value)? enums,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $KitchenSinkTwinRustAsyncCopyWith<$Res> {
  factory $KitchenSinkTwinRustAsyncCopyWith(KitchenSinkTwinRustAsync value,
          $Res Function(KitchenSinkTwinRustAsync) then) =
      _$KitchenSinkTwinRustAsyncCopyWithImpl<$Res, KitchenSinkTwinRustAsync>;
}

/// @nodoc
class _$KitchenSinkTwinRustAsyncCopyWithImpl<$Res,
        $Val extends KitchenSinkTwinRustAsync>
    implements $KitchenSinkTwinRustAsyncCopyWith<$Res> {
  _$KitchenSinkTwinRustAsyncCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$KitchenSinkTwinRustAsync_EmptyImplCopyWith<$Res> {
  factory _$$KitchenSinkTwinRustAsync_EmptyImplCopyWith(
          _$KitchenSinkTwinRustAsync_EmptyImpl value,
          $Res Function(_$KitchenSinkTwinRustAsync_EmptyImpl) then) =
      __$$KitchenSinkTwinRustAsync_EmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$KitchenSinkTwinRustAsync_EmptyImplCopyWithImpl<$Res>
    extends _$KitchenSinkTwinRustAsyncCopyWithImpl<$Res,
        _$KitchenSinkTwinRustAsync_EmptyImpl>
    implements _$$KitchenSinkTwinRustAsync_EmptyImplCopyWith<$Res> {
  __$$KitchenSinkTwinRustAsync_EmptyImplCopyWithImpl(
      _$KitchenSinkTwinRustAsync_EmptyImpl _value,
      $Res Function(_$KitchenSinkTwinRustAsync_EmptyImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$KitchenSinkTwinRustAsync_EmptyImpl
    extends KitchenSinkTwinRustAsync_Empty {
  const _$KitchenSinkTwinRustAsync_EmptyImpl({final String? $type})
      : $type = $type ?? 'empty',
        super._();

  factory _$KitchenSinkTwinRustAsync_EmptyImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$KitchenSinkTwinRustAsync_EmptyImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsync.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KitchenSinkTwinRustAsync_EmptyImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(int int32, double float64, bool boolean)
        primitives,
    required TResult Function(int field0, KitchenSinkTwinRustAsync field1)
        nested,
    required TResult Function(int? field0, int? field1) optional,
    required TResult Function(Uint8List field0) buffer,
    required TResult Function(WeekdaysTwinRustAsync field0) enums,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(int int32, double float64, bool boolean)? primitives,
    TResult? Function(int field0, KitchenSinkTwinRustAsync field1)? nested,
    TResult? Function(int? field0, int? field1)? optional,
    TResult? Function(Uint8List field0)? buffer,
    TResult? Function(WeekdaysTwinRustAsync field0)? enums,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(int int32, double float64, bool boolean)? primitives,
    TResult Function(int field0, KitchenSinkTwinRustAsync field1)? nested,
    TResult Function(int? field0, int? field1)? optional,
    TResult Function(Uint8List field0)? buffer,
    TResult Function(WeekdaysTwinRustAsync field0)? enums,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(KitchenSinkTwinRustAsync_Empty value) empty,
    required TResult Function(KitchenSinkTwinRustAsync_Primitives value)
        primitives,
    required TResult Function(KitchenSinkTwinRustAsync_Nested value) nested,
    required TResult Function(KitchenSinkTwinRustAsync_Optional value) optional,
    required TResult Function(KitchenSinkTwinRustAsync_Buffer value) buffer,
    required TResult Function(KitchenSinkTwinRustAsync_Enums value) enums,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(KitchenSinkTwinRustAsync_Empty value)? empty,
    TResult? Function(KitchenSinkTwinRustAsync_Primitives value)? primitives,
    TResult? Function(KitchenSinkTwinRustAsync_Nested value)? nested,
    TResult? Function(KitchenSinkTwinRustAsync_Optional value)? optional,
    TResult? Function(KitchenSinkTwinRustAsync_Buffer value)? buffer,
    TResult? Function(KitchenSinkTwinRustAsync_Enums value)? enums,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(KitchenSinkTwinRustAsync_Empty value)? empty,
    TResult Function(KitchenSinkTwinRustAsync_Primitives value)? primitives,
    TResult Function(KitchenSinkTwinRustAsync_Nested value)? nested,
    TResult Function(KitchenSinkTwinRustAsync_Optional value)? optional,
    TResult Function(KitchenSinkTwinRustAsync_Buffer value)? buffer,
    TResult Function(KitchenSinkTwinRustAsync_Enums value)? enums,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$KitchenSinkTwinRustAsync_EmptyImplToJson(
      this,
    );
  }
}

abstract class KitchenSinkTwinRustAsync_Empty extends KitchenSinkTwinRustAsync {
  const factory KitchenSinkTwinRustAsync_Empty() =
      _$KitchenSinkTwinRustAsync_EmptyImpl;
  const KitchenSinkTwinRustAsync_Empty._() : super._();

  factory KitchenSinkTwinRustAsync_Empty.fromJson(Map<String, dynamic> json) =
      _$KitchenSinkTwinRustAsync_EmptyImpl.fromJson;
}

/// @nodoc
abstract class _$$KitchenSinkTwinRustAsync_PrimitivesImplCopyWith<$Res> {
  factory _$$KitchenSinkTwinRustAsync_PrimitivesImplCopyWith(
          _$KitchenSinkTwinRustAsync_PrimitivesImpl value,
          $Res Function(_$KitchenSinkTwinRustAsync_PrimitivesImpl) then) =
      __$$KitchenSinkTwinRustAsync_PrimitivesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int int32, double float64, bool boolean});
}

/// @nodoc
class __$$KitchenSinkTwinRustAsync_PrimitivesImplCopyWithImpl<$Res>
    extends _$KitchenSinkTwinRustAsyncCopyWithImpl<$Res,
        _$KitchenSinkTwinRustAsync_PrimitivesImpl>
    implements _$$KitchenSinkTwinRustAsync_PrimitivesImplCopyWith<$Res> {
  __$$KitchenSinkTwinRustAsync_PrimitivesImplCopyWithImpl(
      _$KitchenSinkTwinRustAsync_PrimitivesImpl _value,
      $Res Function(_$KitchenSinkTwinRustAsync_PrimitivesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? int32 = null,
    Object? float64 = null,
    Object? boolean = null,
  }) {
    return _then(_$KitchenSinkTwinRustAsync_PrimitivesImpl(
      int32: null == int32
          ? _value.int32
          : int32 // ignore: cast_nullable_to_non_nullable
              as int,
      float64: null == float64
          ? _value.float64
          : float64 // ignore: cast_nullable_to_non_nullable
              as double,
      boolean: null == boolean
          ? _value.boolean
          : boolean // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$KitchenSinkTwinRustAsync_PrimitivesImpl
    extends KitchenSinkTwinRustAsync_Primitives {
  const _$KitchenSinkTwinRustAsync_PrimitivesImpl(
      {this.int32 = -1,
      required this.float64,
      required this.boolean,
      final String? $type})
      : $type = $type ?? 'primitives',
        super._();

  factory _$KitchenSinkTwinRustAsync_PrimitivesImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$KitchenSinkTwinRustAsync_PrimitivesImplFromJson(json);

  /// Dart field comment
  @override
  @JsonKey()
  final int int32;
  @override
  final double float64;
  @override
  final bool boolean;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsync.primitives(int32: $int32, float64: $float64, boolean: $boolean)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KitchenSinkTwinRustAsync_PrimitivesImpl &&
            (identical(other.int32, int32) || other.int32 == int32) &&
            (identical(other.float64, float64) || other.float64 == float64) &&
            (identical(other.boolean, boolean) || other.boolean == boolean));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, int32, float64, boolean);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$KitchenSinkTwinRustAsync_PrimitivesImplCopyWith<
          _$KitchenSinkTwinRustAsync_PrimitivesImpl>
      get copyWith => __$$KitchenSinkTwinRustAsync_PrimitivesImplCopyWithImpl<
          _$KitchenSinkTwinRustAsync_PrimitivesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(int int32, double float64, bool boolean)
        primitives,
    required TResult Function(int field0, KitchenSinkTwinRustAsync field1)
        nested,
    required TResult Function(int? field0, int? field1) optional,
    required TResult Function(Uint8List field0) buffer,
    required TResult Function(WeekdaysTwinRustAsync field0) enums,
  }) {
    return primitives(int32, float64, boolean);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(int int32, double float64, bool boolean)? primitives,
    TResult? Function(int field0, KitchenSinkTwinRustAsync field1)? nested,
    TResult? Function(int? field0, int? field1)? optional,
    TResult? Function(Uint8List field0)? buffer,
    TResult? Function(WeekdaysTwinRustAsync field0)? enums,
  }) {
    return primitives?.call(int32, float64, boolean);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(int int32, double float64, bool boolean)? primitives,
    TResult Function(int field0, KitchenSinkTwinRustAsync field1)? nested,
    TResult Function(int? field0, int? field1)? optional,
    TResult Function(Uint8List field0)? buffer,
    TResult Function(WeekdaysTwinRustAsync field0)? enums,
    required TResult orElse(),
  }) {
    if (primitives != null) {
      return primitives(int32, float64, boolean);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(KitchenSinkTwinRustAsync_Empty value) empty,
    required TResult Function(KitchenSinkTwinRustAsync_Primitives value)
        primitives,
    required TResult Function(KitchenSinkTwinRustAsync_Nested value) nested,
    required TResult Function(KitchenSinkTwinRustAsync_Optional value) optional,
    required TResult Function(KitchenSinkTwinRustAsync_Buffer value) buffer,
    required TResult Function(KitchenSinkTwinRustAsync_Enums value) enums,
  }) {
    return primitives(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(KitchenSinkTwinRustAsync_Empty value)? empty,
    TResult? Function(KitchenSinkTwinRustAsync_Primitives value)? primitives,
    TResult? Function(KitchenSinkTwinRustAsync_Nested value)? nested,
    TResult? Function(KitchenSinkTwinRustAsync_Optional value)? optional,
    TResult? Function(KitchenSinkTwinRustAsync_Buffer value)? buffer,
    TResult? Function(KitchenSinkTwinRustAsync_Enums value)? enums,
  }) {
    return primitives?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(KitchenSinkTwinRustAsync_Empty value)? empty,
    TResult Function(KitchenSinkTwinRustAsync_Primitives value)? primitives,
    TResult Function(KitchenSinkTwinRustAsync_Nested value)? nested,
    TResult Function(KitchenSinkTwinRustAsync_Optional value)? optional,
    TResult Function(KitchenSinkTwinRustAsync_Buffer value)? buffer,
    TResult Function(KitchenSinkTwinRustAsync_Enums value)? enums,
    required TResult orElse(),
  }) {
    if (primitives != null) {
      return primitives(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$KitchenSinkTwinRustAsync_PrimitivesImplToJson(
      this,
    );
  }
}

abstract class KitchenSinkTwinRustAsync_Primitives
    extends KitchenSinkTwinRustAsync {
  const factory KitchenSinkTwinRustAsync_Primitives(
      {final int int32,
      required final double float64,
      required final bool boolean}) = _$KitchenSinkTwinRustAsync_PrimitivesImpl;
  const KitchenSinkTwinRustAsync_Primitives._() : super._();

  factory KitchenSinkTwinRustAsync_Primitives.fromJson(
          Map<String, dynamic> json) =
      _$KitchenSinkTwinRustAsync_PrimitivesImpl.fromJson;

  /// Dart field comment
  int get int32;
  double get float64;
  bool get boolean;
  @JsonKey(ignore: true)
  _$$KitchenSinkTwinRustAsync_PrimitivesImplCopyWith<
          _$KitchenSinkTwinRustAsync_PrimitivesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$KitchenSinkTwinRustAsync_NestedImplCopyWith<$Res> {
  factory _$$KitchenSinkTwinRustAsync_NestedImplCopyWith(
          _$KitchenSinkTwinRustAsync_NestedImpl value,
          $Res Function(_$KitchenSinkTwinRustAsync_NestedImpl) then) =
      __$$KitchenSinkTwinRustAsync_NestedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0, KitchenSinkTwinRustAsync field1});

  $KitchenSinkTwinRustAsyncCopyWith<$Res> get field1;
}

/// @nodoc
class __$$KitchenSinkTwinRustAsync_NestedImplCopyWithImpl<$Res>
    extends _$KitchenSinkTwinRustAsyncCopyWithImpl<$Res,
        _$KitchenSinkTwinRustAsync_NestedImpl>
    implements _$$KitchenSinkTwinRustAsync_NestedImplCopyWith<$Res> {
  __$$KitchenSinkTwinRustAsync_NestedImplCopyWithImpl(
      _$KitchenSinkTwinRustAsync_NestedImpl _value,
      $Res Function(_$KitchenSinkTwinRustAsync_NestedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$KitchenSinkTwinRustAsync_NestedImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as KitchenSinkTwinRustAsync,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $KitchenSinkTwinRustAsyncCopyWith<$Res> get field1 {
    return $KitchenSinkTwinRustAsyncCopyWith<$Res>(_value.field1, (value) {
      return _then(_value.copyWith(field1: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$KitchenSinkTwinRustAsync_NestedImpl
    extends KitchenSinkTwinRustAsync_Nested {
  const _$KitchenSinkTwinRustAsync_NestedImpl(this.field0,
      [this.field1 = const KitchenSinkTwinRustAsync.empty(),
      final String? $type])
      : $type = $type ?? 'nested',
        super._();

  factory _$KitchenSinkTwinRustAsync_NestedImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$KitchenSinkTwinRustAsync_NestedImplFromJson(json);

  @override
  final int field0;
  @override
  @JsonKey()
  final KitchenSinkTwinRustAsync field1;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsync.nested(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KitchenSinkTwinRustAsync_NestedImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$KitchenSinkTwinRustAsync_NestedImplCopyWith<
          _$KitchenSinkTwinRustAsync_NestedImpl>
      get copyWith => __$$KitchenSinkTwinRustAsync_NestedImplCopyWithImpl<
          _$KitchenSinkTwinRustAsync_NestedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(int int32, double float64, bool boolean)
        primitives,
    required TResult Function(int field0, KitchenSinkTwinRustAsync field1)
        nested,
    required TResult Function(int? field0, int? field1) optional,
    required TResult Function(Uint8List field0) buffer,
    required TResult Function(WeekdaysTwinRustAsync field0) enums,
  }) {
    return nested(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(int int32, double float64, bool boolean)? primitives,
    TResult? Function(int field0, KitchenSinkTwinRustAsync field1)? nested,
    TResult? Function(int? field0, int? field1)? optional,
    TResult? Function(Uint8List field0)? buffer,
    TResult? Function(WeekdaysTwinRustAsync field0)? enums,
  }) {
    return nested?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(int int32, double float64, bool boolean)? primitives,
    TResult Function(int field0, KitchenSinkTwinRustAsync field1)? nested,
    TResult Function(int? field0, int? field1)? optional,
    TResult Function(Uint8List field0)? buffer,
    TResult Function(WeekdaysTwinRustAsync field0)? enums,
    required TResult orElse(),
  }) {
    if (nested != null) {
      return nested(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(KitchenSinkTwinRustAsync_Empty value) empty,
    required TResult Function(KitchenSinkTwinRustAsync_Primitives value)
        primitives,
    required TResult Function(KitchenSinkTwinRustAsync_Nested value) nested,
    required TResult Function(KitchenSinkTwinRustAsync_Optional value) optional,
    required TResult Function(KitchenSinkTwinRustAsync_Buffer value) buffer,
    required TResult Function(KitchenSinkTwinRustAsync_Enums value) enums,
  }) {
    return nested(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(KitchenSinkTwinRustAsync_Empty value)? empty,
    TResult? Function(KitchenSinkTwinRustAsync_Primitives value)? primitives,
    TResult? Function(KitchenSinkTwinRustAsync_Nested value)? nested,
    TResult? Function(KitchenSinkTwinRustAsync_Optional value)? optional,
    TResult? Function(KitchenSinkTwinRustAsync_Buffer value)? buffer,
    TResult? Function(KitchenSinkTwinRustAsync_Enums value)? enums,
  }) {
    return nested?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(KitchenSinkTwinRustAsync_Empty value)? empty,
    TResult Function(KitchenSinkTwinRustAsync_Primitives value)? primitives,
    TResult Function(KitchenSinkTwinRustAsync_Nested value)? nested,
    TResult Function(KitchenSinkTwinRustAsync_Optional value)? optional,
    TResult Function(KitchenSinkTwinRustAsync_Buffer value)? buffer,
    TResult Function(KitchenSinkTwinRustAsync_Enums value)? enums,
    required TResult orElse(),
  }) {
    if (nested != null) {
      return nested(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$KitchenSinkTwinRustAsync_NestedImplToJson(
      this,
    );
  }
}

abstract class KitchenSinkTwinRustAsync_Nested
    extends KitchenSinkTwinRustAsync {
  const factory KitchenSinkTwinRustAsync_Nested(final int field0,
          [final KitchenSinkTwinRustAsync field1]) =
      _$KitchenSinkTwinRustAsync_NestedImpl;
  const KitchenSinkTwinRustAsync_Nested._() : super._();

  factory KitchenSinkTwinRustAsync_Nested.fromJson(Map<String, dynamic> json) =
      _$KitchenSinkTwinRustAsync_NestedImpl.fromJson;

  int get field0;
  KitchenSinkTwinRustAsync get field1;
  @JsonKey(ignore: true)
  _$$KitchenSinkTwinRustAsync_NestedImplCopyWith<
          _$KitchenSinkTwinRustAsync_NestedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$KitchenSinkTwinRustAsync_OptionalImplCopyWith<$Res> {
  factory _$$KitchenSinkTwinRustAsync_OptionalImplCopyWith(
          _$KitchenSinkTwinRustAsync_OptionalImpl value,
          $Res Function(_$KitchenSinkTwinRustAsync_OptionalImpl) then) =
      __$$KitchenSinkTwinRustAsync_OptionalImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int? field0, int? field1});
}

/// @nodoc
class __$$KitchenSinkTwinRustAsync_OptionalImplCopyWithImpl<$Res>
    extends _$KitchenSinkTwinRustAsyncCopyWithImpl<$Res,
        _$KitchenSinkTwinRustAsync_OptionalImpl>
    implements _$$KitchenSinkTwinRustAsync_OptionalImplCopyWith<$Res> {
  __$$KitchenSinkTwinRustAsync_OptionalImplCopyWithImpl(
      _$KitchenSinkTwinRustAsync_OptionalImpl _value,
      $Res Function(_$KitchenSinkTwinRustAsync_OptionalImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = freezed,
    Object? field1 = freezed,
  }) {
    return _then(_$KitchenSinkTwinRustAsync_OptionalImpl(
      freezed == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int?,
      freezed == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$KitchenSinkTwinRustAsync_OptionalImpl
    extends KitchenSinkTwinRustAsync_Optional {
  const _$KitchenSinkTwinRustAsync_OptionalImpl(
      [this.field0 = -1, this.field1, final String? $type])
      : $type = $type ?? 'optional',
        super._();

  factory _$KitchenSinkTwinRustAsync_OptionalImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$KitchenSinkTwinRustAsync_OptionalImplFromJson(json);

  /// Comment on anonymous field
  @override
  @JsonKey()
  final int? field0;
  @override
  final int? field1;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsync.optional(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KitchenSinkTwinRustAsync_OptionalImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$KitchenSinkTwinRustAsync_OptionalImplCopyWith<
          _$KitchenSinkTwinRustAsync_OptionalImpl>
      get copyWith => __$$KitchenSinkTwinRustAsync_OptionalImplCopyWithImpl<
          _$KitchenSinkTwinRustAsync_OptionalImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(int int32, double float64, bool boolean)
        primitives,
    required TResult Function(int field0, KitchenSinkTwinRustAsync field1)
        nested,
    required TResult Function(int? field0, int? field1) optional,
    required TResult Function(Uint8List field0) buffer,
    required TResult Function(WeekdaysTwinRustAsync field0) enums,
  }) {
    return optional(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(int int32, double float64, bool boolean)? primitives,
    TResult? Function(int field0, KitchenSinkTwinRustAsync field1)? nested,
    TResult? Function(int? field0, int? field1)? optional,
    TResult? Function(Uint8List field0)? buffer,
    TResult? Function(WeekdaysTwinRustAsync field0)? enums,
  }) {
    return optional?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(int int32, double float64, bool boolean)? primitives,
    TResult Function(int field0, KitchenSinkTwinRustAsync field1)? nested,
    TResult Function(int? field0, int? field1)? optional,
    TResult Function(Uint8List field0)? buffer,
    TResult Function(WeekdaysTwinRustAsync field0)? enums,
    required TResult orElse(),
  }) {
    if (optional != null) {
      return optional(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(KitchenSinkTwinRustAsync_Empty value) empty,
    required TResult Function(KitchenSinkTwinRustAsync_Primitives value)
        primitives,
    required TResult Function(KitchenSinkTwinRustAsync_Nested value) nested,
    required TResult Function(KitchenSinkTwinRustAsync_Optional value) optional,
    required TResult Function(KitchenSinkTwinRustAsync_Buffer value) buffer,
    required TResult Function(KitchenSinkTwinRustAsync_Enums value) enums,
  }) {
    return optional(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(KitchenSinkTwinRustAsync_Empty value)? empty,
    TResult? Function(KitchenSinkTwinRustAsync_Primitives value)? primitives,
    TResult? Function(KitchenSinkTwinRustAsync_Nested value)? nested,
    TResult? Function(KitchenSinkTwinRustAsync_Optional value)? optional,
    TResult? Function(KitchenSinkTwinRustAsync_Buffer value)? buffer,
    TResult? Function(KitchenSinkTwinRustAsync_Enums value)? enums,
  }) {
    return optional?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(KitchenSinkTwinRustAsync_Empty value)? empty,
    TResult Function(KitchenSinkTwinRustAsync_Primitives value)? primitives,
    TResult Function(KitchenSinkTwinRustAsync_Nested value)? nested,
    TResult Function(KitchenSinkTwinRustAsync_Optional value)? optional,
    TResult Function(KitchenSinkTwinRustAsync_Buffer value)? buffer,
    TResult Function(KitchenSinkTwinRustAsync_Enums value)? enums,
    required TResult orElse(),
  }) {
    if (optional != null) {
      return optional(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$KitchenSinkTwinRustAsync_OptionalImplToJson(
      this,
    );
  }
}

abstract class KitchenSinkTwinRustAsync_Optional
    extends KitchenSinkTwinRustAsync {
  const factory KitchenSinkTwinRustAsync_Optional(
      [final int? field0,
      final int? field1]) = _$KitchenSinkTwinRustAsync_OptionalImpl;
  const KitchenSinkTwinRustAsync_Optional._() : super._();

  factory KitchenSinkTwinRustAsync_Optional.fromJson(
          Map<String, dynamic> json) =
      _$KitchenSinkTwinRustAsync_OptionalImpl.fromJson;

  /// Comment on anonymous field
  int? get field0;
  int? get field1;
  @JsonKey(ignore: true)
  _$$KitchenSinkTwinRustAsync_OptionalImplCopyWith<
          _$KitchenSinkTwinRustAsync_OptionalImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$KitchenSinkTwinRustAsync_BufferImplCopyWith<$Res> {
  factory _$$KitchenSinkTwinRustAsync_BufferImplCopyWith(
          _$KitchenSinkTwinRustAsync_BufferImpl value,
          $Res Function(_$KitchenSinkTwinRustAsync_BufferImpl) then) =
      __$$KitchenSinkTwinRustAsync_BufferImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class __$$KitchenSinkTwinRustAsync_BufferImplCopyWithImpl<$Res>
    extends _$KitchenSinkTwinRustAsyncCopyWithImpl<$Res,
        _$KitchenSinkTwinRustAsync_BufferImpl>
    implements _$$KitchenSinkTwinRustAsync_BufferImplCopyWith<$Res> {
  __$$KitchenSinkTwinRustAsync_BufferImplCopyWithImpl(
      _$KitchenSinkTwinRustAsync_BufferImpl _value,
      $Res Function(_$KitchenSinkTwinRustAsync_BufferImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$KitchenSinkTwinRustAsync_BufferImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$KitchenSinkTwinRustAsync_BufferImpl
    extends KitchenSinkTwinRustAsync_Buffer {
  const _$KitchenSinkTwinRustAsync_BufferImpl(this.field0,
      {final String? $type})
      : $type = $type ?? 'buffer',
        super._();

  factory _$KitchenSinkTwinRustAsync_BufferImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$KitchenSinkTwinRustAsync_BufferImplFromJson(json);

  @override
  final Uint8List field0;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsync.buffer(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KitchenSinkTwinRustAsync_BufferImpl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$KitchenSinkTwinRustAsync_BufferImplCopyWith<
          _$KitchenSinkTwinRustAsync_BufferImpl>
      get copyWith => __$$KitchenSinkTwinRustAsync_BufferImplCopyWithImpl<
          _$KitchenSinkTwinRustAsync_BufferImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(int int32, double float64, bool boolean)
        primitives,
    required TResult Function(int field0, KitchenSinkTwinRustAsync field1)
        nested,
    required TResult Function(int? field0, int? field1) optional,
    required TResult Function(Uint8List field0) buffer,
    required TResult Function(WeekdaysTwinRustAsync field0) enums,
  }) {
    return buffer(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(int int32, double float64, bool boolean)? primitives,
    TResult? Function(int field0, KitchenSinkTwinRustAsync field1)? nested,
    TResult? Function(int? field0, int? field1)? optional,
    TResult? Function(Uint8List field0)? buffer,
    TResult? Function(WeekdaysTwinRustAsync field0)? enums,
  }) {
    return buffer?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(int int32, double float64, bool boolean)? primitives,
    TResult Function(int field0, KitchenSinkTwinRustAsync field1)? nested,
    TResult Function(int? field0, int? field1)? optional,
    TResult Function(Uint8List field0)? buffer,
    TResult Function(WeekdaysTwinRustAsync field0)? enums,
    required TResult orElse(),
  }) {
    if (buffer != null) {
      return buffer(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(KitchenSinkTwinRustAsync_Empty value) empty,
    required TResult Function(KitchenSinkTwinRustAsync_Primitives value)
        primitives,
    required TResult Function(KitchenSinkTwinRustAsync_Nested value) nested,
    required TResult Function(KitchenSinkTwinRustAsync_Optional value) optional,
    required TResult Function(KitchenSinkTwinRustAsync_Buffer value) buffer,
    required TResult Function(KitchenSinkTwinRustAsync_Enums value) enums,
  }) {
    return buffer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(KitchenSinkTwinRustAsync_Empty value)? empty,
    TResult? Function(KitchenSinkTwinRustAsync_Primitives value)? primitives,
    TResult? Function(KitchenSinkTwinRustAsync_Nested value)? nested,
    TResult? Function(KitchenSinkTwinRustAsync_Optional value)? optional,
    TResult? Function(KitchenSinkTwinRustAsync_Buffer value)? buffer,
    TResult? Function(KitchenSinkTwinRustAsync_Enums value)? enums,
  }) {
    return buffer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(KitchenSinkTwinRustAsync_Empty value)? empty,
    TResult Function(KitchenSinkTwinRustAsync_Primitives value)? primitives,
    TResult Function(KitchenSinkTwinRustAsync_Nested value)? nested,
    TResult Function(KitchenSinkTwinRustAsync_Optional value)? optional,
    TResult Function(KitchenSinkTwinRustAsync_Buffer value)? buffer,
    TResult Function(KitchenSinkTwinRustAsync_Enums value)? enums,
    required TResult orElse(),
  }) {
    if (buffer != null) {
      return buffer(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$KitchenSinkTwinRustAsync_BufferImplToJson(
      this,
    );
  }
}

abstract class KitchenSinkTwinRustAsync_Buffer
    extends KitchenSinkTwinRustAsync {
  const factory KitchenSinkTwinRustAsync_Buffer(final Uint8List field0) =
      _$KitchenSinkTwinRustAsync_BufferImpl;
  const KitchenSinkTwinRustAsync_Buffer._() : super._();

  factory KitchenSinkTwinRustAsync_Buffer.fromJson(Map<String, dynamic> json) =
      _$KitchenSinkTwinRustAsync_BufferImpl.fromJson;

  Uint8List get field0;
  @JsonKey(ignore: true)
  _$$KitchenSinkTwinRustAsync_BufferImplCopyWith<
          _$KitchenSinkTwinRustAsync_BufferImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$KitchenSinkTwinRustAsync_EnumsImplCopyWith<$Res> {
  factory _$$KitchenSinkTwinRustAsync_EnumsImplCopyWith(
          _$KitchenSinkTwinRustAsync_EnumsImpl value,
          $Res Function(_$KitchenSinkTwinRustAsync_EnumsImpl) then) =
      __$$KitchenSinkTwinRustAsync_EnumsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({WeekdaysTwinRustAsync field0});
}

/// @nodoc
class __$$KitchenSinkTwinRustAsync_EnumsImplCopyWithImpl<$Res>
    extends _$KitchenSinkTwinRustAsyncCopyWithImpl<$Res,
        _$KitchenSinkTwinRustAsync_EnumsImpl>
    implements _$$KitchenSinkTwinRustAsync_EnumsImplCopyWith<$Res> {
  __$$KitchenSinkTwinRustAsync_EnumsImplCopyWithImpl(
      _$KitchenSinkTwinRustAsync_EnumsImpl _value,
      $Res Function(_$KitchenSinkTwinRustAsync_EnumsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$KitchenSinkTwinRustAsync_EnumsImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as WeekdaysTwinRustAsync,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$KitchenSinkTwinRustAsync_EnumsImpl
    extends KitchenSinkTwinRustAsync_Enums {
  const _$KitchenSinkTwinRustAsync_EnumsImpl(
      [this.field0 = WeekdaysTwinRustAsync.sunday, final String? $type])
      : $type = $type ?? 'enums',
        super._();

  factory _$KitchenSinkTwinRustAsync_EnumsImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$KitchenSinkTwinRustAsync_EnumsImplFromJson(json);

  @override
  @JsonKey()
  final WeekdaysTwinRustAsync field0;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'KitchenSinkTwinRustAsync.enums(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KitchenSinkTwinRustAsync_EnumsImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$KitchenSinkTwinRustAsync_EnumsImplCopyWith<
          _$KitchenSinkTwinRustAsync_EnumsImpl>
      get copyWith => __$$KitchenSinkTwinRustAsync_EnumsImplCopyWithImpl<
          _$KitchenSinkTwinRustAsync_EnumsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(int int32, double float64, bool boolean)
        primitives,
    required TResult Function(int field0, KitchenSinkTwinRustAsync field1)
        nested,
    required TResult Function(int? field0, int? field1) optional,
    required TResult Function(Uint8List field0) buffer,
    required TResult Function(WeekdaysTwinRustAsync field0) enums,
  }) {
    return enums(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(int int32, double float64, bool boolean)? primitives,
    TResult? Function(int field0, KitchenSinkTwinRustAsync field1)? nested,
    TResult? Function(int? field0, int? field1)? optional,
    TResult? Function(Uint8List field0)? buffer,
    TResult? Function(WeekdaysTwinRustAsync field0)? enums,
  }) {
    return enums?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(int int32, double float64, bool boolean)? primitives,
    TResult Function(int field0, KitchenSinkTwinRustAsync field1)? nested,
    TResult Function(int? field0, int? field1)? optional,
    TResult Function(Uint8List field0)? buffer,
    TResult Function(WeekdaysTwinRustAsync field0)? enums,
    required TResult orElse(),
  }) {
    if (enums != null) {
      return enums(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(KitchenSinkTwinRustAsync_Empty value) empty,
    required TResult Function(KitchenSinkTwinRustAsync_Primitives value)
        primitives,
    required TResult Function(KitchenSinkTwinRustAsync_Nested value) nested,
    required TResult Function(KitchenSinkTwinRustAsync_Optional value) optional,
    required TResult Function(KitchenSinkTwinRustAsync_Buffer value) buffer,
    required TResult Function(KitchenSinkTwinRustAsync_Enums value) enums,
  }) {
    return enums(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(KitchenSinkTwinRustAsync_Empty value)? empty,
    TResult? Function(KitchenSinkTwinRustAsync_Primitives value)? primitives,
    TResult? Function(KitchenSinkTwinRustAsync_Nested value)? nested,
    TResult? Function(KitchenSinkTwinRustAsync_Optional value)? optional,
    TResult? Function(KitchenSinkTwinRustAsync_Buffer value)? buffer,
    TResult? Function(KitchenSinkTwinRustAsync_Enums value)? enums,
  }) {
    return enums?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(KitchenSinkTwinRustAsync_Empty value)? empty,
    TResult Function(KitchenSinkTwinRustAsync_Primitives value)? primitives,
    TResult Function(KitchenSinkTwinRustAsync_Nested value)? nested,
    TResult Function(KitchenSinkTwinRustAsync_Optional value)? optional,
    TResult Function(KitchenSinkTwinRustAsync_Buffer value)? buffer,
    TResult Function(KitchenSinkTwinRustAsync_Enums value)? enums,
    required TResult orElse(),
  }) {
    if (enums != null) {
      return enums(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$KitchenSinkTwinRustAsync_EnumsImplToJson(
      this,
    );
  }
}

abstract class KitchenSinkTwinRustAsync_Enums extends KitchenSinkTwinRustAsync {
  const factory KitchenSinkTwinRustAsync_Enums(
          [final WeekdaysTwinRustAsync field0]) =
      _$KitchenSinkTwinRustAsync_EnumsImpl;
  const KitchenSinkTwinRustAsync_Enums._() : super._();

  factory KitchenSinkTwinRustAsync_Enums.fromJson(Map<String, dynamic> json) =
      _$KitchenSinkTwinRustAsync_EnumsImpl.fromJson;

  WeekdaysTwinRustAsync get field0;
  @JsonKey(ignore: true)
  _$$KitchenSinkTwinRustAsync_EnumsImplCopyWith<
          _$KitchenSinkTwinRustAsync_EnumsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MeasureTwinRustAsync _$MeasureTwinRustAsyncFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'speed':
      return MeasureTwinRustAsync_Speed.fromJson(json);
    case 'distance':
      return MeasureTwinRustAsync_Distance.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json,
          'runtimeType',
          'MeasureTwinRustAsync',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$MeasureTwinRustAsync {
  Object get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(SpeedTwinRustAsync field0) speed,
    required TResult Function(DistanceTwinRustAsync field0) distance,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(SpeedTwinRustAsync field0)? speed,
    TResult? Function(DistanceTwinRustAsync field0)? distance,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(SpeedTwinRustAsync field0)? speed,
    TResult Function(DistanceTwinRustAsync field0)? distance,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasureTwinRustAsync_Speed value) speed,
    required TResult Function(MeasureTwinRustAsync_Distance value) distance,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasureTwinRustAsync_Speed value)? speed,
    TResult? Function(MeasureTwinRustAsync_Distance value)? distance,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasureTwinRustAsync_Speed value)? speed,
    TResult Function(MeasureTwinRustAsync_Distance value)? distance,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MeasureTwinRustAsyncCopyWith<$Res> {
  factory $MeasureTwinRustAsyncCopyWith(MeasureTwinRustAsync value,
          $Res Function(MeasureTwinRustAsync) then) =
      _$MeasureTwinRustAsyncCopyWithImpl<$Res, MeasureTwinRustAsync>;
}

/// @nodoc
class _$MeasureTwinRustAsyncCopyWithImpl<$Res,
        $Val extends MeasureTwinRustAsync>
    implements $MeasureTwinRustAsyncCopyWith<$Res> {
  _$MeasureTwinRustAsyncCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$MeasureTwinRustAsync_SpeedImplCopyWith<$Res> {
  factory _$$MeasureTwinRustAsync_SpeedImplCopyWith(
          _$MeasureTwinRustAsync_SpeedImpl value,
          $Res Function(_$MeasureTwinRustAsync_SpeedImpl) then) =
      __$$MeasureTwinRustAsync_SpeedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SpeedTwinRustAsync field0});

  $SpeedTwinRustAsyncCopyWith<$Res> get field0;
}

/// @nodoc
class __$$MeasureTwinRustAsync_SpeedImplCopyWithImpl<$Res>
    extends _$MeasureTwinRustAsyncCopyWithImpl<$Res,
        _$MeasureTwinRustAsync_SpeedImpl>
    implements _$$MeasureTwinRustAsync_SpeedImplCopyWith<$Res> {
  __$$MeasureTwinRustAsync_SpeedImplCopyWithImpl(
      _$MeasureTwinRustAsync_SpeedImpl _value,
      $Res Function(_$MeasureTwinRustAsync_SpeedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$MeasureTwinRustAsync_SpeedImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as SpeedTwinRustAsync,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $SpeedTwinRustAsyncCopyWith<$Res> get field0 {
    return $SpeedTwinRustAsyncCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$MeasureTwinRustAsync_SpeedImpl extends MeasureTwinRustAsync_Speed {
  const _$MeasureTwinRustAsync_SpeedImpl(this.field0, {final String? $type})
      : $type = $type ?? 'speed',
        super._();

  factory _$MeasureTwinRustAsync_SpeedImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MeasureTwinRustAsync_SpeedImplFromJson(json);

  @override
  final SpeedTwinRustAsync field0;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'MeasureTwinRustAsync.speed(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasureTwinRustAsync_SpeedImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MeasureTwinRustAsync_SpeedImplCopyWith<_$MeasureTwinRustAsync_SpeedImpl>
      get copyWith => __$$MeasureTwinRustAsync_SpeedImplCopyWithImpl<
          _$MeasureTwinRustAsync_SpeedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(SpeedTwinRustAsync field0) speed,
    required TResult Function(DistanceTwinRustAsync field0) distance,
  }) {
    return speed(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(SpeedTwinRustAsync field0)? speed,
    TResult? Function(DistanceTwinRustAsync field0)? distance,
  }) {
    return speed?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(SpeedTwinRustAsync field0)? speed,
    TResult Function(DistanceTwinRustAsync field0)? distance,
    required TResult orElse(),
  }) {
    if (speed != null) {
      return speed(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasureTwinRustAsync_Speed value) speed,
    required TResult Function(MeasureTwinRustAsync_Distance value) distance,
  }) {
    return speed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasureTwinRustAsync_Speed value)? speed,
    TResult? Function(MeasureTwinRustAsync_Distance value)? distance,
  }) {
    return speed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasureTwinRustAsync_Speed value)? speed,
    TResult Function(MeasureTwinRustAsync_Distance value)? distance,
    required TResult orElse(),
  }) {
    if (speed != null) {
      return speed(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MeasureTwinRustAsync_SpeedImplToJson(
      this,
    );
  }
}

abstract class MeasureTwinRustAsync_Speed extends MeasureTwinRustAsync {
  const factory MeasureTwinRustAsync_Speed(final SpeedTwinRustAsync field0) =
      _$MeasureTwinRustAsync_SpeedImpl;
  const MeasureTwinRustAsync_Speed._() : super._();

  factory MeasureTwinRustAsync_Speed.fromJson(Map<String, dynamic> json) =
      _$MeasureTwinRustAsync_SpeedImpl.fromJson;

  @override
  SpeedTwinRustAsync get field0;
  @JsonKey(ignore: true)
  _$$MeasureTwinRustAsync_SpeedImplCopyWith<_$MeasureTwinRustAsync_SpeedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MeasureTwinRustAsync_DistanceImplCopyWith<$Res> {
  factory _$$MeasureTwinRustAsync_DistanceImplCopyWith(
          _$MeasureTwinRustAsync_DistanceImpl value,
          $Res Function(_$MeasureTwinRustAsync_DistanceImpl) then) =
      __$$MeasureTwinRustAsync_DistanceImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DistanceTwinRustAsync field0});

  $DistanceTwinRustAsyncCopyWith<$Res> get field0;
}

/// @nodoc
class __$$MeasureTwinRustAsync_DistanceImplCopyWithImpl<$Res>
    extends _$MeasureTwinRustAsyncCopyWithImpl<$Res,
        _$MeasureTwinRustAsync_DistanceImpl>
    implements _$$MeasureTwinRustAsync_DistanceImplCopyWith<$Res> {
  __$$MeasureTwinRustAsync_DistanceImplCopyWithImpl(
      _$MeasureTwinRustAsync_DistanceImpl _value,
      $Res Function(_$MeasureTwinRustAsync_DistanceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$MeasureTwinRustAsync_DistanceImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as DistanceTwinRustAsync,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DistanceTwinRustAsyncCopyWith<$Res> get field0 {
    return $DistanceTwinRustAsyncCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$MeasureTwinRustAsync_DistanceImpl
    extends MeasureTwinRustAsync_Distance {
  const _$MeasureTwinRustAsync_DistanceImpl(this.field0, {final String? $type})
      : $type = $type ?? 'distance',
        super._();

  factory _$MeasureTwinRustAsync_DistanceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$MeasureTwinRustAsync_DistanceImplFromJson(json);

  @override
  final DistanceTwinRustAsync field0;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'MeasureTwinRustAsync.distance(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasureTwinRustAsync_DistanceImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MeasureTwinRustAsync_DistanceImplCopyWith<
          _$MeasureTwinRustAsync_DistanceImpl>
      get copyWith => __$$MeasureTwinRustAsync_DistanceImplCopyWithImpl<
          _$MeasureTwinRustAsync_DistanceImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(SpeedTwinRustAsync field0) speed,
    required TResult Function(DistanceTwinRustAsync field0) distance,
  }) {
    return distance(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(SpeedTwinRustAsync field0)? speed,
    TResult? Function(DistanceTwinRustAsync field0)? distance,
  }) {
    return distance?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(SpeedTwinRustAsync field0)? speed,
    TResult Function(DistanceTwinRustAsync field0)? distance,
    required TResult orElse(),
  }) {
    if (distance != null) {
      return distance(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasureTwinRustAsync_Speed value) speed,
    required TResult Function(MeasureTwinRustAsync_Distance value) distance,
  }) {
    return distance(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasureTwinRustAsync_Speed value)? speed,
    TResult? Function(MeasureTwinRustAsync_Distance value)? distance,
  }) {
    return distance?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasureTwinRustAsync_Speed value)? speed,
    TResult Function(MeasureTwinRustAsync_Distance value)? distance,
    required TResult orElse(),
  }) {
    if (distance != null) {
      return distance(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MeasureTwinRustAsync_DistanceImplToJson(
      this,
    );
  }
}

abstract class MeasureTwinRustAsync_Distance extends MeasureTwinRustAsync {
  const factory MeasureTwinRustAsync_Distance(
      final DistanceTwinRustAsync field0) = _$MeasureTwinRustAsync_DistanceImpl;
  const MeasureTwinRustAsync_Distance._() : super._();

  factory MeasureTwinRustAsync_Distance.fromJson(Map<String, dynamic> json) =
      _$MeasureTwinRustAsync_DistanceImpl.fromJson;

  @override
  DistanceTwinRustAsync get field0;
  @JsonKey(ignore: true)
  _$$MeasureTwinRustAsync_DistanceImplCopyWith<
          _$MeasureTwinRustAsync_DistanceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

SpeedTwinRustAsync _$SpeedTwinRustAsyncFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'unknown':
      return SpeedTwinRustAsync_Unknown.fromJson(json);
    case 'gps':
      return SpeedTwinRustAsync_GPS.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'SpeedTwinRustAsync',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$SpeedTwinRustAsync {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function(double field0) gps,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function(double field0)? gps,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function(double field0)? gps,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SpeedTwinRustAsync_Unknown value) unknown,
    required TResult Function(SpeedTwinRustAsync_GPS value) gps,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SpeedTwinRustAsync_Unknown value)? unknown,
    TResult? Function(SpeedTwinRustAsync_GPS value)? gps,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SpeedTwinRustAsync_Unknown value)? unknown,
    TResult Function(SpeedTwinRustAsync_GPS value)? gps,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpeedTwinRustAsyncCopyWith<$Res> {
  factory $SpeedTwinRustAsyncCopyWith(
          SpeedTwinRustAsync value, $Res Function(SpeedTwinRustAsync) then) =
      _$SpeedTwinRustAsyncCopyWithImpl<$Res, SpeedTwinRustAsync>;
}

/// @nodoc
class _$SpeedTwinRustAsyncCopyWithImpl<$Res, $Val extends SpeedTwinRustAsync>
    implements $SpeedTwinRustAsyncCopyWith<$Res> {
  _$SpeedTwinRustAsyncCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SpeedTwinRustAsync_UnknownImplCopyWith<$Res> {
  factory _$$SpeedTwinRustAsync_UnknownImplCopyWith(
          _$SpeedTwinRustAsync_UnknownImpl value,
          $Res Function(_$SpeedTwinRustAsync_UnknownImpl) then) =
      __$$SpeedTwinRustAsync_UnknownImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SpeedTwinRustAsync_UnknownImplCopyWithImpl<$Res>
    extends _$SpeedTwinRustAsyncCopyWithImpl<$Res,
        _$SpeedTwinRustAsync_UnknownImpl>
    implements _$$SpeedTwinRustAsync_UnknownImplCopyWith<$Res> {
  __$$SpeedTwinRustAsync_UnknownImplCopyWithImpl(
      _$SpeedTwinRustAsync_UnknownImpl _value,
      $Res Function(_$SpeedTwinRustAsync_UnknownImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$SpeedTwinRustAsync_UnknownImpl extends SpeedTwinRustAsync_Unknown {
  const _$SpeedTwinRustAsync_UnknownImpl({final String? $type})
      : $type = $type ?? 'unknown',
        super._();

  factory _$SpeedTwinRustAsync_UnknownImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$SpeedTwinRustAsync_UnknownImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'SpeedTwinRustAsync.unknown()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SpeedTwinRustAsync_UnknownImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function(double field0) gps,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function(double field0)? gps,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function(double field0)? gps,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SpeedTwinRustAsync_Unknown value) unknown,
    required TResult Function(SpeedTwinRustAsync_GPS value) gps,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SpeedTwinRustAsync_Unknown value)? unknown,
    TResult? Function(SpeedTwinRustAsync_GPS value)? gps,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SpeedTwinRustAsync_Unknown value)? unknown,
    TResult Function(SpeedTwinRustAsync_GPS value)? gps,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$SpeedTwinRustAsync_UnknownImplToJson(
      this,
    );
  }
}

abstract class SpeedTwinRustAsync_Unknown extends SpeedTwinRustAsync {
  const factory SpeedTwinRustAsync_Unknown() = _$SpeedTwinRustAsync_UnknownImpl;
  const SpeedTwinRustAsync_Unknown._() : super._();

  factory SpeedTwinRustAsync_Unknown.fromJson(Map<String, dynamic> json) =
      _$SpeedTwinRustAsync_UnknownImpl.fromJson;
}

/// @nodoc
abstract class _$$SpeedTwinRustAsync_GPSImplCopyWith<$Res> {
  factory _$$SpeedTwinRustAsync_GPSImplCopyWith(
          _$SpeedTwinRustAsync_GPSImpl value,
          $Res Function(_$SpeedTwinRustAsync_GPSImpl) then) =
      __$$SpeedTwinRustAsync_GPSImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$SpeedTwinRustAsync_GPSImplCopyWithImpl<$Res>
    extends _$SpeedTwinRustAsyncCopyWithImpl<$Res, _$SpeedTwinRustAsync_GPSImpl>
    implements _$$SpeedTwinRustAsync_GPSImplCopyWith<$Res> {
  __$$SpeedTwinRustAsync_GPSImplCopyWithImpl(
      _$SpeedTwinRustAsync_GPSImpl _value,
      $Res Function(_$SpeedTwinRustAsync_GPSImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SpeedTwinRustAsync_GPSImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SpeedTwinRustAsync_GPSImpl extends SpeedTwinRustAsync_GPS {
  const _$SpeedTwinRustAsync_GPSImpl(this.field0, {final String? $type})
      : $type = $type ?? 'gps',
        super._();

  factory _$SpeedTwinRustAsync_GPSImpl.fromJson(Map<String, dynamic> json) =>
      _$$SpeedTwinRustAsync_GPSImplFromJson(json);

  @override
  final double field0;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'SpeedTwinRustAsync.gps(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SpeedTwinRustAsync_GPSImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SpeedTwinRustAsync_GPSImplCopyWith<_$SpeedTwinRustAsync_GPSImpl>
      get copyWith => __$$SpeedTwinRustAsync_GPSImplCopyWithImpl<
          _$SpeedTwinRustAsync_GPSImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function(double field0) gps,
  }) {
    return gps(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function(double field0)? gps,
  }) {
    return gps?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function(double field0)? gps,
    required TResult orElse(),
  }) {
    if (gps != null) {
      return gps(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SpeedTwinRustAsync_Unknown value) unknown,
    required TResult Function(SpeedTwinRustAsync_GPS value) gps,
  }) {
    return gps(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SpeedTwinRustAsync_Unknown value)? unknown,
    TResult? Function(SpeedTwinRustAsync_GPS value)? gps,
  }) {
    return gps?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SpeedTwinRustAsync_Unknown value)? unknown,
    TResult Function(SpeedTwinRustAsync_GPS value)? gps,
    required TResult orElse(),
  }) {
    if (gps != null) {
      return gps(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$SpeedTwinRustAsync_GPSImplToJson(
      this,
    );
  }
}

abstract class SpeedTwinRustAsync_GPS extends SpeedTwinRustAsync {
  const factory SpeedTwinRustAsync_GPS(final double field0) =
      _$SpeedTwinRustAsync_GPSImpl;
  const SpeedTwinRustAsync_GPS._() : super._();

  factory SpeedTwinRustAsync_GPS.fromJson(Map<String, dynamic> json) =
      _$SpeedTwinRustAsync_GPSImpl.fromJson;

  double get field0;
  @JsonKey(ignore: true)
  _$$SpeedTwinRustAsync_GPSImplCopyWith<_$SpeedTwinRustAsync_GPSImpl>
      get copyWith => throw _privateConstructorUsedError;
}
